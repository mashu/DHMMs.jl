var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Model-Types","page":"API","title":"Model Types","text":"","category":"section"},{"location":"api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/#Output-Types","page":"API","title":"Output Types","text":"","category":"section"},{"location":"api/#DHMMs.SegmentHMM","page":"API","title":"DHMMs.SegmentHMM","text":"SegmentHMM{M<:ModelMode, H<:HMM}\n\nSegment detection HMM parameterized by mode M.\n\nFields\n\nhmm::H: underlying HiddenMarkovModels.HMM\nstates::Vector{StateInfo}: state metadata (type, pattern_idx, position)\npattern_lengths::Vector{Int}: length of each pattern\n\n\n\n\n\n","category":"type"},{"location":"api/#DHMMs.NullMode","page":"API","title":"DHMMs.NullMode","text":"NullMode <: ModelMode\n\nBackground-only model. Topology: N ⟲\n\n\n\n\n\n","category":"type"},{"location":"api/#DHMMs.SingleMode","page":"API","title":"DHMMs.SingleMode","text":"SingleMode <: ModelMode\n\nSingle pattern model. Topology: N₀ ⟲ → Pᵢ → N₁ ⟲\n\nAllows at most one pattern segment with optional skip.\n\n\n\n\n\n","category":"type"},{"location":"api/#DHMMs.LoopMode","page":"API","title":"DHMMs.LoopMode","text":"LoopMode <: ModelMode\n\nLoop model allowing multiple patterns. Topology: N ⟲ ⇄ Pᵢ ⟲\n\nPatterns can chain directly via p_direct parameter.\n\n\n\n\n\n","category":"type"},{"location":"api/#DHMMs.decode","page":"API","title":"DHMMs.decode","text":"decode(m::SegmentHMM, obs::AbstractVector{Int}) -> Vector{Segment}\n\nDecode observation sequence into segments using Viterbi.\n\n\n\n\n\n","category":"function"},{"location":"api/#DHMMs.Segment","page":"API","title":"DHMMs.Segment","text":"Segment\n\nDecoded segment from Viterbi path.\n\nFields\n\ntype::Symbol: :N (background) or :P (pattern)\npattern::Int: pattern index (0 for background)\nstart::Int: start position in observation\nstop::Int: end position in observation\n\n\n\n\n\n","category":"type"},{"location":"#DHMMs.jl","page":"Home","title":"DHMMs.jl","text":"Segment detection Hidden Markov Models.","category":"section"},{"location":"#Models","page":"Home","title":"Models","text":"Mode Topology Description\nNullMode N ⟲ Background only\nSingleMode N₀ ⟲ → Pᵢ → N₁ ⟲ At most one pattern\nLoopMode N ⟲ ⇄ Pᵢ ⟲ Multiple patterns","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using DHMMs\n\npatterns = [[1,2,3], [3,3,1,2]]\nm = SegmentHMM(LoopMode(), patterns)\n\nobs = [4, 4, 1, 2, 3, 4, 4]\nll = logdensityof(m, obs)\nsegments = decode(m, obs)","category":"section"},{"location":"example/#Example:-Detecting-D-Segments-in-CDR3","page":"Example","title":"Example: Detecting D Segments in CDR3","text":"This example shows how to detect IGHD gene segments in CDR3 sequences using DHMMs.","category":"section"},{"location":"example/#Setup","page":"Example","title":"Setup","text":"using DHMMs\nusing BioSequences\nusing FASTX","category":"section"},{"location":"example/#Helper-Functions","page":"Example","title":"Helper Functions","text":"Convert DNA to integer encoding (A=1, C=2, G=3, T=4):\n\nfunction dna_to_int(nt::DNA)\n    nt == DNA_A && return 1\n    nt == DNA_C && return 2\n    nt == DNA_G && return 3\n    nt == DNA_T && return 4\n    error(\"Unknown nucleotide: $nt\")\nend\n\nseq_to_ints(seq::LongDNA{4}) = [dna_to_int(nt) for nt in seq]","category":"section"},{"location":"example/#Load-D-Genes","page":"Example","title":"Load D Genes","text":"function load_d_genes(fasta_path::String)\n    genes = Vector{Int}[]\n    names = String[]\n    for record in FASTAReader(open(fasta_path))\n        push!(names, description(record))\n        push!(genes, seq_to_ints(sequence(LongDNA{4}, record)))\n    end\n    names, genes\nend\n\n# Example: load from file\n# names, patterns = load_d_genes(\"IGHD.fasta\")\n\n# Or define manually:\nd_genes = [\n    dna\"GGTATAGTGGGAGCTAC\",      # IGHD1-1\n    dna\"AGGATATTGTAGTAGTAC\",     # IGHD2-2  \n    dna\"GTATTACTATGGTTCGGGGAGTTATTATAAC\",  # IGHD3-3\n]\npatterns = [seq_to_ints(g) for g in d_genes]","category":"section"},{"location":"example/#Build-Models","page":"Example","title":"Build Models","text":"# Null model: no D segment (background only)\nm_null = SegmentHMM(NullMode(), patterns)\n\n# Single model: at most one D segment\nm_single = SegmentHMM(SingleMode(), patterns; \n    p_stay_n=0.6, p_continue=0.9, match_prob=0.85)\n\n# Loop model: multiple D segments allowed\nm_loop = SegmentHMM(LoopMode(), patterns;\n    p_stay_n=0.75, p_continue=0.95, p_direct=0.01, match_prob=0.85)","category":"section"},{"location":"example/#Analyze-a-CDR3-Sequence","page":"Example","title":"Analyze a CDR3 Sequence","text":"# Example CDR3 with potential double-D\ncdr3 = dna\"AATTATTGTGGTGGTGATTGCTATGCGAATGTATAGCAGTGGCTGATGC\"\nobs = seq_to_ints(cdr3)\n\n# Compare model likelihoods\nll_null = logdensityof(m_null, obs)\nll_single = logdensityof(m_single, obs)\nll_loop = logdensityof(m_loop, obs)\n\n# Log-odds for D presence\nlog_odds_has_d = ll_single - ll_null\nprintln(\"Evidence for D: \", log_odds_has_d)\n\n# Log-odds for multiple Ds\nlog_odds_multi = ll_loop - ll_single  \nprintln(\"Evidence for multiple D: \", log_odds_multi)","category":"section"},{"location":"example/#Decode-Segments","page":"Example","title":"Decode Segments","text":"segments = decode(m_loop, obs)\n\nfor seg in segments\n    region = String(cdr3[seg.start:seg.stop])\n    if seg.type == :P\n        println(\"D$(seg.pattern): $region ($(seg.start)-$(seg.stop))\")\n    else\n        println(\"N: $region ($(seg.start)-$(seg.stop))\")\n    end\nend","category":"section"},{"location":"example/#Decision-Thresholds","page":"Example","title":"Decision Thresholds","text":"function analyze_cdr3(cdr3::LongDNA{4}, patterns; threshold=1.0)\n    obs = seq_to_ints(cdr3)\n    \n    m_null = SegmentHMM(NullMode(), patterns)\n    m_single = SegmentHMM(SingleMode(), patterns)\n    m_loop = SegmentHMM(LoopMode(), patterns)\n    \n    ll_null = logdensityof(m_null, obs)\n    ll_single = logdensityof(m_single, obs)\n    ll_loop = logdensityof(m_loop, obs)\n    \n    has_d = (ll_single - ll_null) > threshold\n    has_multi_d = (ll_loop - ll_single) > threshold\n    \n    segments = decode(m_loop, obs)\n    d_count = count(s -> s.type == :P, segments)\n    \n    (has_d=has_d, has_multi_d=has_multi_d, d_count=d_count, segments=segments)\nend\n\nresult = analyze_cdr3(cdr3, patterns)\nprintln(\"Has D: \", result.has_d)\nprintln(\"Has multiple D: \", result.has_multi_d)\nprintln(\"D segments found: \", result.d_count)","category":"section"},{"location":"example/#Negative-Example:-Random-Sequence","page":"Example","title":"Negative Example: Random Sequence","text":"Test with a random sequence that should NOT match any D gene:\n\n# Random sequence with no D gene content\nrandom_cdr3 = dna\"AAAAAACCCCCCGGGGGGTTTTTT\"\nobs_random = seq_to_ints(random_cdr3)\n\nll_null = logdensityof(m_null, obs_random)\nll_single = logdensityof(m_single, obs_random)\nll_loop = logdensityof(m_loop, obs_random)\n\nlog_odds_d = ll_single - ll_null\nprintln(\"Random seq - Evidence for D: \", log_odds_d)  # Should be negative or near zero\n\nsegments = decode(m_loop, obs_random)\nd_segments = filter(s -> s.type == :P, segments)\nprintln(\"D segments found: \", length(d_segments))  # Should be 0 or spurious short matches\n\nExpected output: negative log-odds indicating no D gene evidence.","category":"section"},{"location":"example/#Positive-vs-Negative-Comparison","page":"Example","title":"Positive vs Negative Comparison","text":"# Positive: CDR3 containing actual D gene sequence\ncdr3_with_d = dna\"TTTTGGTATAGTGGGAGCTACAAAA\"  # Contains IGHD1-1\nobs_pos = seq_to_ints(cdr3_with_d)\n\n# Negative: same length, no D gene\ncdr3_without_d = dna\"TTTTAAACCCGGGTTTAAACCCCCC\"\nobs_neg = seq_to_ints(cdr3_without_d)\n\n# Compare\nfor (name, obs) in [(\"With D\", obs_pos), (\"Without D\", obs_neg)]\n    ll_null = logdensityof(m_null, obs)\n    ll_single = logdensityof(m_single, obs)\n    log_odds = ll_single - ll_null\n    println(\"$name: log-odds = $(round(log_odds, digits=2))\")\nend\n# Expected: \"With D\" has positive log-odds, \"Without D\" has negative/zero","category":"section"},{"location":"example/#Batch-Processing","page":"Example","title":"Batch Processing","text":"function process_cdr3s(cdr3_seqs::Vector{LongDNA{4}}, patterns)\n    # Build models once\n    m_null = SegmentHMM(NullMode(), patterns)\n    m_single = SegmentHMM(SingleMode(), patterns)\n    m_loop = SegmentHMM(LoopMode(), patterns)\n    \n    results = map(cdr3_seqs) do cdr3\n        obs = seq_to_ints(cdr3)\n        \n        ll_null = logdensityof(m_null, obs)\n        ll_single = logdensityof(m_single, obs)\n        ll_loop = logdensityof(m_loop, obs)\n        \n        (\n            cdr3 = cdr3,\n            log_odds_d = ll_single - ll_null,\n            log_odds_multi = ll_loop - ll_single,\n            segments = decode(m_loop, obs)\n        )\n    end\n    results\nend","category":"section"}]
}
